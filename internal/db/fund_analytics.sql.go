// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: fund_analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFundAnalytics = `-- name: GetFundAnalytics :one
SELECT scheme_code, "window", rolling_min, rolling_max, rolling_median, rolling_p25, rolling_p75, max_drawdown, cagr_min, cagr_max, cagr_median, data_start_date, data_end_date, nav_points, rolling_periods, computed_at
FROM fund_analytics
WHERE scheme_code = $1
  AND "window" = $2
`

type GetFundAnalyticsParams struct {
	SchemeCode string `json:"scheme_code"`
	Window     string `json:"window"`
}

func (q *Queries) GetFundAnalytics(ctx context.Context, arg GetFundAnalyticsParams) (FundAnalytic, error) {
	row := q.db.QueryRow(ctx, getFundAnalytics, arg.SchemeCode, arg.Window)
	var i FundAnalytic
	err := row.Scan(
		&i.SchemeCode,
		&i.Window,
		&i.RollingMin,
		&i.RollingMax,
		&i.RollingMedian,
		&i.RollingP25,
		&i.RollingP75,
		&i.MaxDrawdown,
		&i.CagrMin,
		&i.CagrMax,
		&i.CagrMedian,
		&i.DataStartDate,
		&i.DataEndDate,
		&i.NavPoints,
		&i.RollingPeriods,
		&i.ComputedAt,
	)
	return i, err
}

const rankFundsByMaxDrawdown = `-- name: RankFundsByMaxDrawdown :many
SELECT
  fa.scheme_code,
  f.scheme_name,
  f.amc,
  f.category,
  fa."window",
  fa.rolling_median,
  fa.max_drawdown
FROM fund_analytics fa
JOIN funds f ON f.scheme_code = fa.scheme_code
WHERE f.category = $1
  AND fa."window" = $2
ORDER BY fa.max_drawdown ASC NULLS LAST
LIMIT $3
`

type RankFundsByMaxDrawdownParams struct {
	Category string `json:"category"`
	Window   string `json:"window"`
	Limit    int32  `json:"limit"`
}

type RankFundsByMaxDrawdownRow struct {
	SchemeCode    string         `json:"scheme_code"`
	SchemeName    string         `json:"scheme_name"`
	Amc           string         `json:"amc"`
	Category      string         `json:"category"`
	Window        string         `json:"window"`
	RollingMedian pgtype.Numeric `json:"rolling_median"`
	MaxDrawdown   pgtype.Numeric `json:"max_drawdown"`
}

func (q *Queries) RankFundsByMaxDrawdown(ctx context.Context, arg RankFundsByMaxDrawdownParams) ([]RankFundsByMaxDrawdownRow, error) {
	rows, err := q.db.Query(ctx, rankFundsByMaxDrawdown, arg.Category, arg.Window, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RankFundsByMaxDrawdownRow{}
	for rows.Next() {
		var i RankFundsByMaxDrawdownRow
		if err := rows.Scan(
			&i.SchemeCode,
			&i.SchemeName,
			&i.Amc,
			&i.Category,
			&i.Window,
			&i.RollingMedian,
			&i.MaxDrawdown,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rankFundsByMedianReturn = `-- name: RankFundsByMedianReturn :many
SELECT
  fa.scheme_code,
  f.scheme_name,
  f.amc,
  f.category,
  fa."window",
  fa.rolling_median,
  fa.max_drawdown
FROM fund_analytics fa
JOIN funds f ON f.scheme_code = fa.scheme_code
WHERE f.category = $1
  AND fa."window" = $2
ORDER BY fa.rolling_median DESC NULLS LAST
LIMIT $3
`

type RankFundsByMedianReturnParams struct {
	Category string `json:"category"`
	Window   string `json:"window"`
	Limit    int32  `json:"limit"`
}

type RankFundsByMedianReturnRow struct {
	SchemeCode    string         `json:"scheme_code"`
	SchemeName    string         `json:"scheme_name"`
	Amc           string         `json:"amc"`
	Category      string         `json:"category"`
	Window        string         `json:"window"`
	RollingMedian pgtype.Numeric `json:"rolling_median"`
	MaxDrawdown   pgtype.Numeric `json:"max_drawdown"`
}

func (q *Queries) RankFundsByMedianReturn(ctx context.Context, arg RankFundsByMedianReturnParams) ([]RankFundsByMedianReturnRow, error) {
	rows, err := q.db.Query(ctx, rankFundsByMedianReturn, arg.Category, arg.Window, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RankFundsByMedianReturnRow{}
	for rows.Next() {
		var i RankFundsByMedianReturnRow
		if err := rows.Scan(
			&i.SchemeCode,
			&i.SchemeName,
			&i.Amc,
			&i.Category,
			&i.Window,
			&i.RollingMedian,
			&i.MaxDrawdown,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFundAnalytics = `-- name: UpsertFundAnalytics :exec
INSERT INTO fund_analytics (
  scheme_code, "window",
  rolling_min, rolling_max, rolling_median, rolling_p25, rolling_p75,
  max_drawdown,
  cagr_min, cagr_max, cagr_median,
  data_start_date, data_end_date, nav_points, rolling_periods,
  computed_at
)
VALUES (
  $1, $2,
  $3, $4, $5, $6, $7,
  $8,
  $9, $10, $11,
  $12, $13, $14, $15,
  NOW()
)
ON CONFLICT (scheme_code, "window") DO UPDATE SET
  rolling_min = EXCLUDED.rolling_min,
  rolling_max = EXCLUDED.rolling_max,
  rolling_median = EXCLUDED.rolling_median,
  rolling_p25 = EXCLUDED.rolling_p25,
  rolling_p75 = EXCLUDED.rolling_p75,
  max_drawdown = EXCLUDED.max_drawdown,
  cagr_min = EXCLUDED.cagr_min,
  cagr_max = EXCLUDED.cagr_max,
  cagr_median = EXCLUDED.cagr_median,
  data_start_date = EXCLUDED.data_start_date,
  data_end_date = EXCLUDED.data_end_date,
  nav_points = EXCLUDED.nav_points,
  rolling_periods = EXCLUDED.rolling_periods,
  computed_at = NOW()
`

type UpsertFundAnalyticsParams struct {
	SchemeCode     string         `json:"scheme_code"`
	Window         string         `json:"window"`
	RollingMin     pgtype.Numeric `json:"rolling_min"`
	RollingMax     pgtype.Numeric `json:"rolling_max"`
	RollingMedian  pgtype.Numeric `json:"rolling_median"`
	RollingP25     pgtype.Numeric `json:"rolling_p25"`
	RollingP75     pgtype.Numeric `json:"rolling_p75"`
	MaxDrawdown    pgtype.Numeric `json:"max_drawdown"`
	CagrMin        pgtype.Numeric `json:"cagr_min"`
	CagrMax        pgtype.Numeric `json:"cagr_max"`
	CagrMedian     pgtype.Numeric `json:"cagr_median"`
	DataStartDate  pgtype.Date    `json:"data_start_date"`
	DataEndDate    pgtype.Date    `json:"data_end_date"`
	NavPoints      pgtype.Int4    `json:"nav_points"`
	RollingPeriods pgtype.Int4    `json:"rolling_periods"`
}

func (q *Queries) UpsertFundAnalytics(ctx context.Context, arg UpsertFundAnalyticsParams) error {
	_, err := q.db.Exec(ctx, upsertFundAnalytics,
		arg.SchemeCode,
		arg.Window,
		arg.RollingMin,
		arg.RollingMax,
		arg.RollingMedian,
		arg.RollingP25,
		arg.RollingP75,
		arg.MaxDrawdown,
		arg.CagrMin,
		arg.CagrMax,
		arg.CagrMedian,
		arg.DataStartDate,
		arg.DataEndDate,
		arg.NavPoints,
		arg.RollingPeriods,
	)
	return err
}
