// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: rate_limiter.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getRateLimiterStateForUpdate = `-- name: GetRateLimiterStateForUpdate :one
SELECT window_type, window_start, request_count, updated_at
FROM rate_limiter_state
WHERE window_type = $1
FOR UPDATE
`

func (q *Queries) GetRateLimiterStateForUpdate(ctx context.Context, windowType string) (RateLimiterState, error) {
	row := q.db.QueryRow(ctx, getRateLimiterStateForUpdate, windowType)
	var i RateLimiterState
	err := row.Scan(
		&i.WindowType,
		&i.WindowStart,
		&i.RequestCount,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertRateLimiterState = `-- name: UpsertRateLimiterState :exec
INSERT INTO rate_limiter_state (window_type, window_start, request_count, updated_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (window_type) DO UPDATE SET
  window_start = EXCLUDED.window_start,
  request_count = EXCLUDED.request_count,
  updated_at = NOW()
`

type UpsertRateLimiterStateParams struct {
	WindowType   string           `json:"window_type"`
	WindowStart  pgtype.Timestamp `json:"window_start"`
	RequestCount int32            `json:"request_count"`
}

func (q *Queries) UpsertRateLimiterState(ctx context.Context, arg UpsertRateLimiterStateParams) error {
	_, err := q.db.Exec(ctx, upsertRateLimiterState, arg.WindowType, arg.WindowStart, arg.RequestCount)
	return err
}
