// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: nav_history.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getLatestNav = `-- name: GetLatestNav :one
SELECT scheme_code, nav_date, nav_value, created_at
FROM nav_history
WHERE scheme_code = $1
ORDER BY nav_date DESC
LIMIT 1
`

func (q *Queries) GetLatestNav(ctx context.Context, schemeCode string) (NavHistory, error) {
	row := q.db.QueryRow(ctx, getLatestNav, schemeCode)
	var i NavHistory
	err := row.Scan(
		&i.SchemeCode,
		&i.NavDate,
		&i.NavValue,
		&i.CreatedAt,
	)
	return i, err
}

const listNavHistoryBetween = `-- name: ListNavHistoryBetween :many
SELECT scheme_code, nav_date, nav_value, created_at
FROM nav_history
WHERE scheme_code = $1
  AND nav_date >= $2
  AND nav_date <= $3
ORDER BY nav_date ASC
`

type ListNavHistoryBetweenParams struct {
	SchemeCode string      `json:"scheme_code"`
	NavDate    pgtype.Date `json:"nav_date"`
	NavDate_2  pgtype.Date `json:"nav_date_2"`
}

func (q *Queries) ListNavHistoryBetween(ctx context.Context, arg ListNavHistoryBetweenParams) ([]NavHistory, error) {
	rows, err := q.db.Query(ctx, listNavHistoryBetween, arg.SchemeCode, arg.NavDate, arg.NavDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NavHistory{}
	for rows.Next() {
		var i NavHistory
		if err := rows.Scan(
			&i.SchemeCode,
			&i.NavDate,
			&i.NavValue,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNavHistoryForScheme = `-- name: ListNavHistoryForScheme :many
SELECT scheme_code, nav_date, nav_value, created_at
FROM nav_history
WHERE scheme_code = $1
ORDER BY nav_date ASC
`

func (q *Queries) ListNavHistoryForScheme(ctx context.Context, schemeCode string) ([]NavHistory, error) {
	rows, err := q.db.Query(ctx, listNavHistoryForScheme, schemeCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NavHistory{}
	for rows.Next() {
		var i NavHistory
		if err := rows.Scan(
			&i.SchemeCode,
			&i.NavDate,
			&i.NavValue,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertNavHistory = `-- name: UpsertNavHistory :exec
INSERT INTO nav_history (scheme_code, nav_date, nav_value, created_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (scheme_code, nav_date) DO UPDATE SET
  nav_value = EXCLUDED.nav_value
`

type UpsertNavHistoryParams struct {
	SchemeCode string          `json:"scheme_code"`
	NavDate    pgtype.Date     `json:"nav_date"`
	NavValue   decimal.Decimal `json:"nav_value"`
}

func (q *Queries) UpsertNavHistory(ctx context.Context, arg UpsertNavHistoryParams) error {
	_, err := q.db.Exec(ctx, upsertNavHistory, arg.SchemeCode, arg.NavDate, arg.NavValue)
	return err
}
